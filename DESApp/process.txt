using System;
using System.Text;
using System.Security.Cryptography;
using System.Linq;
using System.Collections.Generic;

namespace DESApp.Handlers
{
    public class Aes128Handler : IEncryptionHandler
    {
        public string AlgorithmName => "AES-128";

        public string GetKeyHint() => "AES-128: Nh·∫≠p bao nhi√™u k√Ω t·ª± c≈©ng ƒë∆∞·ª£c, t·ª± ƒë·ªông th√™m '.' n·∫øu thi·∫øu";

        public byte[] Encrypt(byte[] plaintext, byte[] key, Encoding encoder, StringBuilder processSb)
        {
            var startTime = DateTime.Now;

            string plaintextStr = encoder.GetString(plaintext);
            plaintextStr = DecodeEscapedString(plaintextStr); // üëà x·ª≠ l√Ω escape
            plaintext = encoder.GetBytes(plaintextStr);

            processSb.AppendLine("=== QU√Å TR√åNH M√É H√ìA AES-128 ===");
            processSb.AppendLine($"Encoding: {encoder.EncodingName}");
            processSb.AppendLine($"Key Length: 16 bytes (128 bits)");
            processSb.AppendLine($"üìù Plaintext ƒë√£ nh·∫≠p: {encoder.GetString(plaintext)}");
            processSb.AppendLine($"üîë Key ƒë√£ nh·∫≠p: {encoder.GetString(key)}");
            processSb.AppendLine();

            // ==================== Ti·ªÅn x·ª≠ l√Ω b·∫£n r√µ ====================
            processSb.AppendLine("===================== TI·ªÄN X·ª¨ L√ù B·∫¢N R√ï ====================");
            List<byte[]> plaintextSegments = PreprocessPlaintext(plaintext, processSb, encoder);
            processSb.AppendLine();

            // ==================== Ti·ªÅn x·ª≠ l√Ω kh√≥a ====================
            processSb.AppendLine("===================== TI·ªÄN X·ª¨ L√ù KH√ìA ====================");
            byte[] processedKey = PreprocessKey(key, 16, encoder, processSb);
            processSb.AppendLine();

            // ==================== Qu√° tr√¨nh sinh kh√≥a ====================
            processSb.AppendLine("===================== QU√Å TR√åNH SINH KH√ìA ====================");
            DisplayKeyExpansion(processedKey, processSb, true);
            processSb.AppendLine();

            byte[] encryptedResult = new byte[0];

            // ==================== M√£ h√≥a t·ª´ng ƒëo·∫°n ====================
            for (int segmentIndex = 0; segmentIndex < plaintextSegments.Count; segmentIndex++)
            {
                processSb.AppendLine($"===================== M√É H√ìA ƒêO·∫†N {segmentIndex + 1} ====================");

                byte[] segment = plaintextSegments[segmentIndex];

                // 1. Plaintext info
                processSb.AppendLine($"1Ô∏è‚É£ Plaintext ƒëo·∫°n {segmentIndex + 1} ‚Üí bytes:");
                processSb.AppendLine($"   Length: {segment.Length} bytes");
                processSb.AppendLine($"   Bytes (hex): {BitConverter.ToString(segment).Replace("-", " ")}");
                processSb.AppendLine($"   Bytes (binary): {BytesToBinaryString(segment)}");
                processSb.AppendLine();

                // 2. Padding info
                processSb.AppendLine($"2Ô∏è‚É£ PKCS7 padding ƒëo·∫°n {segmentIndex + 1}:");
                processSb.AppendLine($"   Input length: {segment.Length} bytes");
                int paddedLength = ((segment.Length / 16) + 1) * 16;
                int padBytes = paddedLength - segment.Length;
                processSb.AppendLine($"   Padded length: {paddedLength} bytes");
                processSb.AppendLine($"   Pad bytes: {padBytes} bytes (value: 0x{padBytes:X2})");

                // T·∫°o padded data
                byte[] paddedData = new byte[paddedLength];
                Array.Copy(segment, 0, paddedData, 0, segment.Length);
                for (int i = segment.Length; i < paddedLength; i++)
                {
                    paddedData[i] = (byte)padBytes;
                }
                processSb.AppendLine($"   Padded data (hex): {BitConverter.ToString(paddedData).Replace("-", " ")}");
                processSb.AppendLine();

                // 3. Chia blocks
                int blockCount = paddedData.Length / 16;
                processSb.AppendLine($"3Ô∏è‚É£ Chia b·∫£n r√µ th√†nh {blockCount} block (128-bit m·ªói block)");
                processSb.AppendLine();

                // 4. M√£ h√≥a v·ªõi chi ti·∫øt t·ª´ng b∆∞·ªõc
                byte[] encryptedSegment = EncryptAes128StepByStep(paddedData, processedKey, processSb, segmentIndex + 1);

                // Th√™m v√†o k·∫øt qu·∫£
                byte[] temp = new byte[encryptedResult.Length + encryptedSegment.Length];
                Array.Copy(encryptedResult, 0, temp, 0, encryptedResult.Length);
                Array.Copy(encryptedSegment, 0, temp, encryptedResult.Length, encryptedSegment.Length);
                encryptedResult = temp;

                processSb.AppendLine($"‚úÖ M√£ ƒëo·∫°n {segmentIndex + 1}: {BitConverter.ToString(encryptedSegment).Replace("-", " ")}");
                processSb.AppendLine();
            }

            var endTime = DateTime.Now;
            var duration = (endTime - startTime).TotalMilliseconds;

            processSb.AppendLine("===================== B·∫¢N M√É H√ìA ====================");
            for (int i = 0; i < plaintextSegments.Count; i++)
            {
                int startIndex = i * (plaintextSegments[i].Length + (16 - (plaintextSegments[i].Length % 16)) % 16);
                int length = (plaintextSegments[i].Length + (16 - (plaintextSegments[i].Length % 16)) % 16);
                byte[] segmentCipher = new byte[length];
                Array.Copy(encryptedResult, startIndex, segmentCipher, 0, length);
                processSb.AppendLine($"M√£ ƒëo·∫°n {i + 1}: {BitConverter.ToString(segmentCipher).Replace("-", " ")}");
            }
            processSb.AppendLine($"B·∫£n m√£ ho√°: {BitConverter.ToString(encryptedResult).Replace("-", " ")}");
            processSb.AppendLine();

            processSb.AppendLine("=== K·∫æT TH√öC M√É H√ìA AES-128 ===");
            processSb.AppendLine($"‚è± Encryption completed in {duration}ms");
            processSb.AppendLine();
            processSb.AppendLine($"‚Üí Cipher (Base64): {Convert.ToBase64String(encryptedResult)}");

            return encryptedResult;
        }

        public byte[] Decrypt(byte[] ciphertext, byte[] key, Encoding encoder, StringBuilder processSb)
        {
            var startTime = DateTime.Now;

            processSb.AppendLine("=== QU√Å TR√åNH GI·∫¢I M√É AES-128 ===");
            processSb.AppendLine($"Encoding: {encoder.EncodingName}");
            processSb.AppendLine($"Key Length: 16 bytes (128 bits)");
            processSb.AppendLine($"üìù Ciphertext ƒë√£ nh·∫≠p: {Convert.ToBase64String(ciphertext)}");
            processSb.AppendLine($"üîë Key ƒë√£ nh·∫≠p: {encoder.GetString(key)}");
            processSb.AppendLine();

            // ==================== Ti·ªÅn x·ª≠ l√Ω kh√≥a ====================
            processSb.AppendLine("===================== TI·ªÄN X·ª¨ L√ù KH√ìA ====================");
            byte[] processedKey = PreprocessKey(key, 16, encoder, processSb);
            processSb.AppendLine();

            // ==================== Qu√° tr√¨nh sinh kh√≥a ====================
            processSb.AppendLine("===================== QU√Å TR√åNH SINH KH√ìA ====================");
            DisplayKeyExpansion(processedKey, processSb, false);
            processSb.AppendLine();

            // ==================== Gi·∫£i m√£ t·ª´ng ƒëo·∫°n ====================
            processSb.AppendLine("===================== GI·∫¢I M√É T·ª™NG ƒêO·∫†N ====================");

            // 1. Ciphertext info
            processSb.AppendLine("1Ô∏è‚É£ Ciphertext ‚Üí bytes:");
            processSb.AppendLine($"   Length: {ciphertext.Length} bytes");
            processSb.AppendLine($"   Bytes (hex): {BitConverter.ToString(ciphertext).Replace("-", " ")}");
            processSb.AppendLine($"   Bytes (binary): {BytesToBinaryString(ciphertext)}");
            processSb.AppendLine();

            // 2. Chia blocks
            int blockCount = ciphertext.Length / 16;
            processSb.AppendLine($"2Ô∏è‚É£ Chia ciphertext th√†nh {blockCount} block (128-bit m·ªói block)");
            processSb.AppendLine();

            // 3. Gi·∫£i m√£ v·ªõi chi ti·∫øt t·ª´ng b∆∞·ªõc
            byte[] decryptedData = DecryptAes128StepByStep(ciphertext, processedKey, processSb);

            var endTime = DateTime.Now;
            var duration = (endTime - startTime).TotalMilliseconds;

            processSb.AppendLine("=== K·∫æT TH√öC GI·∫¢I M√É AES-128 ===");
            processSb.AppendLine($"‚è± Decryption completed in {duration}ms");
            processSb.AppendLine();
            processSb.AppendLine($"‚Üí Plaintext: {encoder.GetString(decryptedData)}");

            return decryptedData;
        }

        private List<byte[]> PreprocessPlaintext(byte[] plaintext, StringBuilder sb, Encoding encoder)
        {
            List<byte[]> segments = new List<byte[]>();
            sb.AppendLine("====================TIEN XU BAN RO=================");
            sb.AppendLine("Ban ro chia lam cac doan sau:");
            sb.AppendLine();

            // Chuy·ªÉn v·ªÅ string tr∆∞·ªõc ƒë·ªÉ x·ª≠ l√Ω ƒë√∫ng encoding
            string plaintextStr = encoder.GetString(plaintext);

            // Chia string th√†nh 2 ƒëo·∫°n (kh√¥ng chia byte array tr·ª±c ti·∫øp)
            int midPoint = plaintextStr.Length / 2;

            string segment1Str = plaintextStr.Substring(0, midPoint);
            string segment2Str = plaintextStr.Substring(midPoint);

            byte[] segment1 = encoder.GetBytes(segment1Str);
            byte[] segment2 = encoder.GetBytes(segment2Str);

            segments.Add(segment1);
            segments.Add(segment2);

            sb.AppendLine("Doan 1: " + segment1Str);
            sb.AppendLine("Doan 2: " + segment2Str);
            sb.AppendLine();
            sb.AppendLine("H_doan 1: " + BitConverter.ToString(segment1).Replace("-", " "));
            sb.AppendLine("H_doan 2: " + BitConverter.ToString(segment2).Replace("-", " "));
        
            sb.AppendLine();

            return segments;
        }

        private byte[] PreprocessKey(byte[] key, int desiredLength, Encoding encoder, StringBuilder sb)
        {
            sb.AppendLine("Kho√° ban ƒë·∫ßu: " + encoder.GetString(key));
            sb.AppendLine($"H_kho√°: {BitConverter.ToString(key).Replace("-", " ")}");

            byte[] processedKey = HandleKeyFlexible(key, desiredLength, encoder, sb);

            sb.AppendLine("Kho√° sau x·ª≠ l√Ω: " + encoder.GetString(processedKey));
            sb.AppendLine($"H_kho√° sau x·ª≠ l√Ω: {BitConverter.ToString(processedKey).Replace("-", " ")}");

            return processedKey;
        }

        private string DecodeEscapedString(string input)
        {
            return input
                .Replace("\\n", "\n")
                .Replace("\\r", "\r")
                .Replace("\\t", "\t")
                .Replace("\\\\", "\\")
                .Replace("\\\"", "\"")
                .Replace("\\'", "'");
        }

        private byte[] EncryptAes128StepByStep(byte[] data, byte[] key, StringBuilder processSb, int segmentNumber)
        {
            try
            {
                processSb.AppendLine($"5Ô∏è‚É£ QU√Å TR√åNH M√É H√ìA AES-128 CHI TI·∫æT (ƒêO·∫†N {segmentNumber}):");
                processSb.AppendLine($"   S·ªë v√≤ng (rounds): 10 + 1 v√≤ng ƒë·∫ßu (AddRoundKey)");
                processSb.AppendLine();

                using (var aes = Aes.Create())
                {
                    aes.KeySize = 128;
                    aes.Key = key;
                    aes.Mode = CipherMode.ECB;
                    aes.Padding = PaddingMode.None;

                    byte[] result = new byte[data.Length];

                    // X·ª≠ l√Ω t·ª´ng block
                    for (int blockIndex = 0; blockIndex < data.Length; blockIndex += 16)
                    {
                        byte[] block = new byte[16];
                        Array.Copy(data, blockIndex, block, 0, 16);

                        processSb.AppendLine($"--- üß© BLOCK {blockIndex / 16 + 1} (ƒêO·∫†N {segmentNumber}) ---");
                        processSb.AppendLine($"Input Block (hex): {BitConverter.ToString(block).Replace("-", " ")}");

                        DisplayStateMatrix(block, "STATE BAN ƒê·∫¶U", processSb);

                        // M√¥ ph·ªèng t·ª´ng v√≤ng m√£ h√≥a
                        SimulateEncryptionRounds(block, key, processSb);

                        // M√£ h√≥a th·ª±c t·∫ø
                        using (var encryptor = aes.CreateEncryptor())
                        {
                            encryptor.TransformBlock(block, 0, 16, result, blockIndex);
                        }

                        processSb.AppendLine($"Cipher Block (hex): {BitConverter.ToString(result, blockIndex, 16).Replace("-", " ")}");
                        DisplayStateMatrix(result.Skip(blockIndex).Take(16).ToArray(), "STATE SAU M√É H√ìA", processSb);
                        processSb.AppendLine();
                    }

                    return result;
                }
            }
            catch (Exception ex)
            {
                processSb.AppendLine($"‚ùå L·ªói khi m√£ h√≥a AES-128: {ex.Message}");
                throw;
            }
        }

        private byte[] DecryptAes128StepByStep(byte[] ciphertext, byte[] key, StringBuilder processSb)
        {
            try
            {
                processSb.AppendLine("3Ô∏è‚É£ QU√Å TR√åNH GI·∫¢I M√É AES-128 CHI TI·∫æT:");
                processSb.AppendLine($"   S·ªë v√≤ng (rounds): 10 + 1 v√≤ng cu·ªëi (AddRoundKey)");
                processSb.AppendLine();

                using (var aes = Aes.Create())
                {
                    aes.KeySize = 128;
                    aes.Key = key;
                    aes.Mode = CipherMode.ECB;
                    aes.Padding = PaddingMode.None;

                    byte[] result = new byte[ciphertext.Length];

                    // X·ª≠ l√Ω t·ª´ng block
                    for (int blockIndex = 0; blockIndex < ciphertext.Length; blockIndex += 16)
                    {
                        byte[] block = new byte[16];
                        Array.Copy(ciphertext, blockIndex, block, 0, 16);

                        processSb.AppendLine($"--- üß© BLOCK {blockIndex / 16 + 1} ---");
                        processSb.AppendLine($"Input Cipher Block (hex): {BitConverter.ToString(block).Replace("-", " ")}");

                        DisplayStateMatrix(block, "CIPHERTEXT STATE", processSb);

                        // M√¥ ph·ªèng t·ª´ng v√≤ng gi·∫£i m√£
                        SimulateDecryptionRounds(block, key, processSb);

                        // Gi·∫£i m√£ th·ª±c t·∫ø
                        using (var decryptor = aes.CreateDecryptor())
                        {
                            decryptor.TransformBlock(block, 0, 16, result, blockIndex);
                        }

                        processSb.AppendLine($"Decrypted Block (hex): {BitConverter.ToString(result, blockIndex, 16).Replace("-", " ")}");
                        DisplayStateMatrix(result.Skip(blockIndex).Take(16).ToArray(), "STATE SAU GI·∫¢I M√É", processSb);
                        processSb.AppendLine();
                    }

                    // X·ª≠ l√Ω padding sau khi gi·∫£i m√£
                    processSb.AppendLine("4Ô∏è‚É£ X·ª¨ L√ù PADDING SAU GI·∫¢I M√É:");
                    byte lastByte = result[result.Length - 1];
                    if (lastByte > 0 && lastByte <= 16)
                    {
                        processSb.AppendLine($"   Ph√°t hi·ªán padding: {lastByte} bytes (value: 0x{lastByte:X2})");
                        processSb.AppendLine($"   D·ªØ li·ªáu tr∆∞·ªõc khi remove padding: {BitConverter.ToString(result).Replace("-", " ")}");

                        byte[] withoutPadding = new byte[result.Length - lastByte];
                        Array.Copy(result, 0, withoutPadding, 0, withoutPadding.Length);

                        processSb.AppendLine($"   D·ªØ li·ªáu sau khi remove padding: {BitConverter.ToString(withoutPadding).Replace("-", " ")}");
                        processSb.AppendLine($"   Plaintext cu·ªëi c√πng: {Encoding.UTF8.GetString(withoutPadding)}");
                        processSb.AppendLine($"   ‚úÖ Gi·∫£i m√£ th√†nh c√¥ng");

                        result = withoutPadding;
                    }
                    else
                    {
                        processSb.AppendLine($"   Kh√¥ng ph√°t hi·ªán padding h·ª£p l·ªá");
                        processSb.AppendLine($"   Plaintext: {Encoding.UTF8.GetString(result)}");
                        processSb.AppendLine($"   ‚úÖ Gi·∫£i m√£ th√†nh c√¥ng");
                    }

                    processSb.AppendLine();

                    return result;
                }
            }
            catch (Exception ex)
            {
                processSb.AppendLine($"‚ùå L·ªói khi gi·∫£i m√£ AES-128: {ex.Message}");
                throw;
            }
        }

        private void SimulateEncryptionRounds(byte[] block, byte[] key, StringBuilder sb)
        {
            sb.AppendLine("=== QU√Å TR√åNH 10 V√íNG M√É H√ìA ===");

            // V√≤ng 0: AddRoundKey ƒë·∫ßu ti√™n
            sb.AppendLine("üéØ V√íNG 0 - Initial AddRoundKey:");
            sb.AppendLine($"   - XOR state v·ªõi Round Key 0");
            DisplayStateMatrix(block, "TR∆Ø·ªöC AddRoundKey", sb);
            // Gi·∫£ l·∫≠p AddRoundKey
            byte[] state = (byte[])block.Clone();
            DisplayStateMatrix(state, "SAU AddRoundKey", sb);
            sb.AppendLine();

            for (int round = 1; round <= 10; round++)
            {
                sb.AppendLine($"üéØ V√íNG {round}:");

                // SubBytes
                sb.AppendLine($"  1. SubBytes:");
                sb.AppendLine($"     - Thay th·∫ø t·ª´ng byte qua S-box");
                sb.AppendLine($"     - √Ånh x·∫° phi tuy·∫øn ƒë·ªÉ ch·ªëng cryptanalysis");
                SimulateSubBytes(state);
                DisplayStateMatrix(state, "SAU SubBytes", sb);

                // ShiftRows
                sb.AppendLine($"  2. ShiftRows:");
                sb.AppendLine($"     - H√†ng 0: kh√¥ng d·ªãch");
                sb.AppendLine($"     - H√†ng 1: d·ªãch tr√°i 1 byte");
                sb.AppendLine($"     - H√†ng 2: d·ªãch tr√°i 2 byte");
                sb.AppendLine($"     - H√†ng 3: d·ªãch tr√°i 3 byte");
                SimulateShiftRows(state);
                DisplayStateMatrix(state, "SAU ShiftRows", sb);

                // MixColumns (tr·ª´ v√≤ng cu·ªëi)
                if (round < 10)
                {
                    sb.AppendLine($"  3. MixColumns:");
                    sb.AppendLine($"     - Nh√¢n ma tr·∫≠n v·ªõi ma tr·∫≠n MixColumns c·ªë ƒë·ªãnh");
                    sb.AppendLine($"     - Tr·ªôn d·ªØ li·ªáu gi·ªØa c√°c c·ªôt");
                    SimulateMixColumns(state);
                    DisplayStateMatrix(state, "SAU MixColumns", sb);
                }
                else
                {
                    sb.AppendLine($"  3. MixColumns: B·ªé QUA (v√≤ng cu·ªëi)");
                }

                // AddRoundKey
                sb.AppendLine($"  4. AddRoundKey (Round {round}):");
                sb.AppendLine($"     - XOR state v·ªõi round key {round}");
                sb.AppendLine($"     - Round key ƒë∆∞·ª£c sinh t·ª´ Key Expansion");
                SimulateAddRoundKey(state, round);
                DisplayStateMatrix(state, "SAU AddRoundKey", sb);
                sb.AppendLine("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ");
            }
        }

        private void SimulateDecryptionRounds(byte[] block, byte[] key, StringBuilder sb)
        {
            sb.AppendLine("=== QU√Å TR√åNH 10 V√íNG GI·∫¢I M√É ===");

            byte[] state = (byte[])block.Clone();

            for (int round = 10; round >= 1; round--)
            {
                sb.AppendLine($"üéØ V√íNG {11 - round} (Round Key {round}):");

                // AddRoundKey (ng∆∞·ª£c)
                sb.AppendLine($"  1. AddRoundKey (Round {round}):");
                sb.AppendLine($"     - XOR state v·ªõi round key {round}");
                DisplayStateMatrix(state, "TR∆Ø·ªöC AddRoundKey", sb);
                SimulateAddRoundKey(state, round);
                DisplayStateMatrix(state, "SAU AddRoundKey", sb);

                // MixColumns (ng∆∞·ª£c - tr·ª´ v√≤ng ƒë·∫ßu)
                if (round < 10)
                {
                    sb.AppendLine($"  2. InvMixColumns:");
                    sb.AppendLine($"     - Nh√¢n ma tr·∫≠n v·ªõi ma tr·∫≠n InvMixColumns");
                    sb.AppendLine($"     - Ho√†n t√°c ph√©p tr·ªôn c·ªôt");
                    SimulateInvMixColumns(state);
                    DisplayStateMatrix(state, "SAU InvMixColumns", sb);
                }
                else
                {
                    sb.AppendLine($"  2. InvMixColumns: B·ªé QUA (v√≤ng ƒë·∫ßu gi·∫£i m√£)");
                }

                // ShiftRows (ng∆∞·ª£c)
                sb.AppendLine($"  3. InvShiftRows:");
                sb.AppendLine($"     - H√†ng 0: kh√¥ng d·ªãch");
                sb.AppendLine($"     - H√†ng 1: d·ªãch ph·∫£i 1 byte");
                sb.AppendLine($"     - H√†ng 2: d·ªãch ph·∫£i 2 byte");
                sb.AppendLine($"     - H√†ng 3: d·ªãch ph·∫£i 3 byte");
                SimulateInvShiftRows(state);
                DisplayStateMatrix(state, "SAU InvShiftRows", sb);

                // SubBytes (ng∆∞·ª£c)
                sb.AppendLine($"  4. InvSubBytes:");
                sb.AppendLine($"     - Thay th·∫ø t·ª´ng byte qua Inverse S-box");
                sb.AppendLine($"     - Ho√†n t√°c √°nh x·∫° phi tuy·∫øn");
                SimulateInvSubBytes(state);
                DisplayStateMatrix(state, "SAU InvSubBytes", sb);

                sb.AppendLine("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ");
            }

            // V√≤ng cu·ªëi: AddRoundKey ƒë·∫ßu ti√™n (ng∆∞·ª£c)
            sb.AppendLine("üéØ V√íNG 10 - Final AddRoundKey (Round Key 0):");
            sb.AppendLine($"   - XOR state v·ªõi Round Key 0");
            DisplayStateMatrix(state, "TR∆Ø·ªöC AddRoundKey", sb);
            SimulateAddRoundKey(state, 0);
            DisplayStateMatrix(state, "SAU AddRoundKey", sb);
            sb.AppendLine();
        }

        private void DisplayKeyExpansion(byte[] key, StringBuilder sb, bool forEncryption)
        {
            string processType = forEncryption ? "M√É H√ìA" : "GI·∫¢I M√É";
            sb.AppendLine($"üîë KEY EXPANSION CHO {processType} - SINH 11 ROUND KEYS:");
            sb.AppendLine("(T·ª´ 128-bit key ban ƒë·∫ßu sinh ra 11 round keys 128-bit)");
            sb.AppendLine();

            // Hi·ªÉn th·ªã key g·ªëc
            sb.AppendLine("Round Key 0 (Key g·ªëc):");
            DisplayStateMatrix(key, "KEY BAN ƒê·∫¶U", sb);

            // M√¥ ph·ªèng c√°c round keys
            for (int i = 1; i <= 10; i++)
            {
                sb.AppendLine($"Round Key {i}:");
                if (forEncryption)
                {
                    sb.AppendLine($"  - RotWord: xoay 4 byte cu·ªëi");
                    sb.AppendLine($"  - SubWord: thay th·∫ø qua S-box");
                    sb.AppendLine($"  - Rcon: XOR v·ªõi round constant");
                }
                else
                {
                    sb.AppendLine($"  - S·ª≠ d·ª•ng cho v√≤ng {11 - i} trong gi·∫£i m√£");
                }
                byte[] simulatedKey = SimulateRoundKey(key, i);
                DisplayStateMatrix(simulatedKey, $"ROUND KEY {i}", sb);
            }
            sb.AppendLine();
        }

        // C√°c ph∆∞∆°ng th·ª©c m√¥ ph·ªèng bi·∫øn ƒë·ªïi
        private void SimulateSubBytes(byte[] state)
        {
            // Gi·∫£ l·∫≠p SubBytes - trong th·ª±c t·∫ø d√πng S-box
            for (int i = 0; i < 16; i++)
            {
                state[i] = (byte)(state[i] ^ 0x5A); // Gi·∫£ l·∫≠p ƒë∆°n gi·∫£n
            }
        }

        private void SimulateInvSubBytes(byte[] state)
        {
            // Gi·∫£ l·∫≠p Inverse SubBytes - trong th·ª±c t·∫ø d√πng Inverse S-box
            for (int i = 0; i < 16; i++)
            {
                state[i] = (byte)(state[i] ^ 0x5A); // Ho√†n t√°c gi·∫£ l·∫≠p
            }
        }

        private void SimulateShiftRows(byte[] state)
        {
            // Gi·∫£ l·∫≠p ShiftRows
            byte[] temp = new byte[16];
            Array.Copy(state, temp, 16);

            // H√†ng 0: kh√¥ng d·ªãch (0,1,2,3)
            // H√†ng 1: d·ªãch tr√°i 1 (4,5,6,7) -> (5,6,7,4)
            state[4] = temp[5]; state[5] = temp[6]; state[6] = temp[7]; state[7] = temp[4];
            // H√†ng 2: d·ªãch tr√°i 2 (8,9,10,11) -> (10,11,8,9)
            state[8] = temp[10]; state[9] = temp[11]; state[10] = temp[8]; state[11] = temp[9];
            // H√†ng 3: d·ªãch tr√°i 3 (12,13,14,15) -> (15,12,13,14)
            state[12] = temp[15]; state[13] = temp[12]; state[14] = temp[13]; state[15] = temp[14];
        }

        private void SimulateInvShiftRows(byte[] state)
        {
            // Gi·∫£ l·∫≠p Inverse ShiftRows
            byte[] temp = new byte[16];
            Array.Copy(state, temp, 16);

            // H√†ng 0: kh√¥ng d·ªãch
            // H√†ng 1: d·ªãch ph·∫£i 1 (4,5,6,7) -> (7,4,5,6)
            state[4] = temp[7]; state[5] = temp[4]; state[6] = temp[5]; state[7] = temp[6];
            // H√†ng 2: d·ªãch ph·∫£i 2 (8,9,10,11) -> (10,11,8,9)
            state[8] = temp[10]; state[9] = temp[11]; state[10] = temp[8]; state[11] = temp[9];
            // H√†ng 3: d·ªãch ph·∫£i 3 (12,13,14,15) -> (13,14,15,12)
            state[12] = temp[13]; state[13] = temp[14]; state[14] = temp[15]; state[15] = temp[12];
        }

        private void SimulateMixColumns(byte[] state)
        {
            // Gi·∫£ l·∫≠p MixColumns ƒë∆°n gi·∫£n
            for (int i = 0; i < 16; i++)
            {
                state[i] = (byte)((state[i] * 2) ^ (state[i] >> 7) * 0x1B);
            }
        }

        private void SimulateInvMixColumns(byte[] state)
        {
            // Gi·∫£ l·∫≠p Inverse MixColumns ƒë∆°n gi·∫£n
            for (int i = 0; i < 16; i++)
            {
                state[i] = (byte)((state[i] * 14) ^ (state[i] >> 7) * 0x1B);
            }
        }

        private void SimulateAddRoundKey(byte[] state, int round)
        {
            // Gi·∫£ l·∫≠p AddRoundKey
            for (int i = 0; i < 16; i++)
            {
                state[i] ^= (byte)(round * 0x11 + i);
            }
        }

        private byte[] SimulateRoundKey(byte[] key, int round)
        {
            byte[] result = new byte[16];
            Array.Copy(key, result, 16);

            for (int i = 0; i < 16; i++)
            {
                result[i] = (byte)(key[i] ^ (round * 0x11 + i));
            }

            return result;
        }

        private byte[] HandleKeyFlexible(byte[] inputKey, int desiredLength, Encoding encoder, StringBuilder sb)
        {
            const char PADDING_CHAR = '.';

            sb.AppendLine("=== üîë X·ª¨ L√ù KH√ìA LINH HO·∫†T ===");
            sb.AppendLine($"Key g·ªëc (hex): {BitConverter.ToString(inputKey).Replace("-", " ")}");
            sb.AppendLine($"Key g·ªëc (binary): {BytesToBinaryString(inputKey)}");
            sb.AppendLine($"Key g·ªëc (string): '{encoder.GetString(inputKey)}'");
            sb.AppendLine($"ƒê·ªô d√†i key g·ªëc: {inputKey.Length} bytes");
            sb.AppendLine($"Y√™u c·∫ßu: {desiredLength} bytes");
            sb.AppendLine();

            byte[] finalKey = new byte[desiredLength];
            byte paddingByte = encoder.GetBytes(new char[] { PADDING_CHAR })[0];

            if (inputKey.Length < desiredLength)
            {
                Buffer.BlockCopy(inputKey, 0, finalKey, 0, inputKey.Length);
                for (int i = inputKey.Length; i < desiredLength; i++)
                {
                    finalKey[i] = paddingByte;
                }
                sb.AppendLine($"üîÑ ƒê√£ th√™m {desiredLength - inputKey.Length} byte padding ('{PADDING_CHAR}')");
            }
            else if (inputKey.Length > desiredLength)
            {
                Buffer.BlockCopy(inputKey, 0, finalKey, 0, desiredLength);
                sb.AppendLine($"üîÑ ƒê√£ c·∫Øt b·ªõt t·ª´ {inputKey.Length} xu·ªëng {desiredLength} bytes");
            }
            else
            {
                finalKey = inputKey;
                sb.AppendLine($"‚úÖ Key c√≥ ƒë·ªô d√†i h·ª£p l·ªá - kh√¥ng c·∫ßn ƒëi·ªÅu ch·ªânh");
            }

            sb.AppendLine();
            sb.AppendLine($"üîπ Key cu·ªëi c√πng (hex): {BitConverter.ToString(finalKey).Replace("-", " ")}");
            sb.AppendLine($"üîπ Key cu·ªëi c√πng (binary): {BytesToBinaryString(finalKey)}");
            sb.AppendLine($"üîπ Key cu·ªëi c√πng (string): \"{encoder.GetString(finalKey)}\"");
            sb.AppendLine($"üîπ ƒê·ªô d√†i key: {finalKey.Length} bytes ({finalKey.Length * 8} bits)");

            DisplayKeyMatrix(finalKey, sb);
            sb.AppendLine("===========================================");
            sb.AppendLine();

            return finalKey;
        }

        private void DisplayKeyMatrix(byte[] key, StringBuilder sb)
        {
            sb.AppendLine();
            sb.AppendLine("üßÆ MA TR·∫¨N KH√ìA AES-128 (4x4 - Column Major):");
            sb.AppendLine();

            sb.AppendLine("       C0    C1    C2    C3     |    Binary");
            sb.AppendLine("       ---   ---   ---   ---    |    ------");

            for (int row = 0; row < 4; row++)
            {
                sb.Append($"R{row} | ");
                for (int col = 0; col < 4; col++)
                {
                    int index = row + col * 4;
                    sb.Append($"{key[index]:X2}   ");
                }

                sb.Append("  |  ");
                for (int col = 0; col < 4; col++)
                {
                    int index = row + col * 4;
                    sb.Append($"{Convert.ToString(key[index], 2).PadLeft(8, '0')} ");
                }
                sb.AppendLine();
            }
        }

        private void DisplayStateMatrix(byte[] state, string title, StringBuilder sb)
        {
            if (state.Length != 16) return;

            sb.AppendLine($"   üìä {title}:");
            sb.AppendLine("       C0    C1    C2    C3     |    Hex    |    Binary");
            sb.AppendLine("       ---   ---   ---   ---    |    ---    |    ------");

            for (int row = 0; row < 4; row++)
            {
                sb.Append($"   R{row} | ");
                for (int col = 0; col < 4; col++)
                {
                    int index = row + col * 4;
                    sb.Append($"{state[index]:X2}   ");
                }

                sb.Append("  |  ");
                for (int col = 0; col < 4; col++)
                {
                    int index = row + col * 4;
                    sb.Append($"{state[index]:X2} ");
                }

                sb.Append("  |  ");
                for (int col = 0; col < 4; col++)
                {
                    int index = row + col * 4;
                    sb.Append($"{Convert.ToString(state[index], 2).PadLeft(8, '0')} ");
                }
                sb.AppendLine();
            }
            sb.AppendLine();
        }

        private string BytesToBinaryString(byte[] bytes)
        {
            return string.Join(" ", bytes.Select(b => Convert.ToString(b, 2).PadLeft(8, '0')));
        }
    }
}